import{_ as n,o as t,c as i,a as s,b as r,w as l,e as d,d as e,r as o}from"./app.e22df933.js";const c={},u=d(`<h1 id="aliase" tabindex="-1"><a class="header-anchor" href="#aliase" aria-hidden="true">#</a> Aliase</h1><p>Aliase in Nushell bieten eine einfache M\xF6glichkeit, um Texte zur ersetzen. Damit ist es m\xF6glich, einen Kurznamen f\xFCr l\xE4ngere Befehle zu definieren - inklusive der Argumente.</p><p>Beispielsweise kann ein Alias namens <code>ll</code> definiert werden, der den l\xE4ngeren Befehl <code>ls -l</code> ersetzt:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; alias ll = ls -l
</code></pre></div><p>Nun kann der Alias aufgerufen werden:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; ll
</code></pre></div><p>Wenn das getan wird, wirkt es, als sei <code>ls -l</code> aufgerufen worden. Das bietet auch die M\xF6glichkeit weitere Parameter anzugeben. So kann auch geschrieben werden:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; ll -a
</code></pre></div><p>Das ist \xE4quivalent zu <code>ls -l -a</code>. Deutlich k\xFCrzer.</p><h2 id="persistenz" tabindex="-1"><a class="header-anchor" href="#persistenz" aria-hidden="true">#</a> Persistenz</h2>`,10),h=e("F\xFCr Informationen, um Aliase dauerhaft zu speichern, damit diese immer in Nushell nutzbar sind, kann ein Blick auf das "),g=e("Konfigurationskapitel"),p=e(" geworfen werden.");function f(_,m){const a=o("RouterLink");return t(),i("div",null,[u,s("p",null,[h,r(a,{to:"/de/book/konfiguration.html"},{default:l(()=>[g]),_:1}),p])])}var k=n(c,[["render",f],["__file","aliase.html.vue"]]);export{k as default};
