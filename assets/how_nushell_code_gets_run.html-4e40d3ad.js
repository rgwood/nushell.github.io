import{_ as l,M as s,p as r,q as c,Q as t,t as e,N as a,U as d,a1 as n}from"./framework-344bb0e4.js";const u={},h=t("h1",{id:"how-nushell-code-gets-run",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#how-nushell-code-gets-run","aria-hidden":"true"},"#"),e(" How Nushell Code Gets Run")],-1),p=t("em",null,"think of Nushell as a compiled language",-1),g=n(`<p>First, let&#39;s give a few example which you might intuitively try but which do not work in Nushell.</p><ol><li>Sourcing a dynamic path</li></ol><div class="language-text" data-ext="text"><pre class="language-text"><code>source $&quot;($my_path)/common.nu&quot;
</code></pre></div><ol start="2"><li>Write to a file and source it in a single script</li></ol><div class="language-text" data-ext="text"><pre class="language-text"><code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu
source &quot;output.nu&quot;
</code></pre></div><ol start="3"><li>Change a directory and source a path within (even though the file exists)</li></ol><div class="language-text" data-ext="text"><pre class="language-text"><code>if (&#39;spam/foo.nu&#39; | path exists) {
    cd spam
    source-env foo.nu
}
</code></pre></div><p>The underlying reason why all of the above examples won&#39;t work is a strict separation of <strong>parsing and evaluation</strong> steps by <strong>disallowing eval function</strong>. In the rest of this section, we&#39;ll explain in detail what it means, why we&#39;re doing it, and what the implications are. The explanation aims to be as simple as possible, but it might help if you&#39;ve written a program in some language before.</p><h2 id="parsing-and-evaluation" tabindex="-1"><a class="header-anchor" href="#parsing-and-evaluation" aria-hidden="true">#</a> Parsing and Evaluation</h2><h3 id="interpreted-languages" tabindex="-1"><a class="header-anchor" href="#interpreted-languages" aria-hidden="true">#</a> Interpreted Languages</h3><p>Let&#39;s start with a simple &quot;hello world&quot; Nushell program:</p><div class="language-text" data-ext="text"><pre class="language-text"><code># hello.nu

print &quot;Hello world!&quot;
</code></pre></div><p>When you run <code>nu hello.nu</code>, Nushell&#39;s interpreter directly runs the program and prints the result to the screen. This is similar (on the highest level) to other languages that are typically interpreted, such as Python or Bash. If you write a similar &quot;hello world&quot; program in any of these languages and call <code>python hello.py</code> or <code>bash hello.bash</code>, the result will be printed to the screen. We can say that interpreters take the program in some representation (e.g., a source code), run it, and give you the result:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>source code --&gt; interpreting --&gt; result
</code></pre></div><p>Under the hood, Nushell&#39;s interpreter is split into two parts, like this:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>1. source code --&gt; parsing --&gt; Intermediate Representation (IR)
2. IR --&gt; evaluating --&gt; result
</code></pre></div>`,16),m={href:"https://en.wikipedia.org/wiki/Bytecode",target:"_blank",rel:"noopener noreferrer"},f=t("h3",{id:"compiled-languages",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#compiled-languages","aria-hidden":"true"},"#"),e(" Compiled Languages")],-1),v={href:"https://doc.rust-lang.org/stable/book/ch01-02-hello-world.html",target:"_blank",rel:"noopener noreferrer"},y=n(`<div class="language-rust" data-ext="rs"><pre class="language-rust"><code><span class="token comment">// main.rs</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>`,1),w=t("em",null,"compile",-1),x={href:"https://en.wikipedia.org/wiki/Machine_code",target:"_blank",rel:"noopener noreferrer"},_=t("code",null,"rustc main.rs",-1),b=t("code",null,"./main",-1),k=t("div",{class:"language-text","data-ext":"text"},[t("pre",{class:"language-text"},[t("code",null,`1. source code --> compiler --> machine code
2. machine code --> CPU --> result
`)])],-1),q=t("p",null,"You can see the compile-run sequence is not that much different from the parse-evaluate sequence of an interpreter. You begin with a source code, parse (or compile) it into some IR (or machine code), then evaluate (or run) the IR to get a result. You could think of machine code as just another type of IR and the CPU as its interpreter.",-1),N=t("p",null,[e("One big difference, however, between interpreted and compiled languages is that interpreted languages typically implement an "),t("em",null,"eval function"),e(" while compiled languages do not. What does it mean?")],-1),E=t("h3",{id:"eval-function",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#eval-function","aria-hidden":"true"},"#"),e(" Eval Function")],-1),P={href:"https://docs.python.org/3/library/functions.html#eval",target:"_blank",rel:"noopener noreferrer"},T={href:"https://docs.python.org/3/library/functions.html#exec",target:"_blank",rel:"noopener noreferrer"},I={href:"https://linux.die.net/man/1/bash",target:"_blank",rel:"noopener noreferrer"},R=n(`<div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token comment"># hello_eval.py</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span>
<span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token string">&quot;print(&#39;Hello eval!&#39;)&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>When you run the file (<code>python hello_eval.py</code>), you&#39;ll see two messages: &quot;Hello world!&quot; and &quot;Hello eval!&quot;. Here is what happened:</p><ol><li>Parse the whole source code</li><li>Evaluate <code>print(&quot;Hello world!&quot;)</code></li><li>To evaluate <code>eval(&quot;print(&#39;Hello eval!&#39;)&quot;)</code>: 3.1. Parse <code>print(&#39;Hello eval!&#39;)</code> 3.2. Evaluate <code>print(&#39;Hello eval!&#39;)</code></li></ol><p>Of course, you can have more fun and try <code>eval(&quot;eval(\\&quot;print(&#39;Hello eval!&#39;)\\&quot;)&quot;)</code> and so on...</p><p>You can see the eval function adds a new &quot;meta&quot; layer into the code execution. Instead of parsing the whole source code, then evaluating it, there is an extra parse-eval step during the evaluation. This means that the IR produced by the parser (whatever it is) can be further modified during the evaluation.</p>`,5),H=t("code",null,"eval",-1),C={href:"https://www.nushell.sh/book/thinking_in_nu.html#think-of-nushell-as-a-compiled-language",target:"_blank",rel:"noopener noreferrer"},W=t("code",null,"eval",-1),L=n(`<h2 id="implications" tabindex="-1"><a class="header-anchor" href="#implications" aria-hidden="true">#</a> Implications</h2><p>Consider this Python example:</p><div class="language-python" data-ext="py"><pre class="language-python"><code><span class="token keyword">exec</span><span class="token punctuation">(</span><span class="token string">&quot;def hello(): print(&#39;Hello eval!&#39;)&quot;</span><span class="token punctuation">)</span>
hello<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><em>Note: We&#39;re using <code>exec</code> instead of <code>eval</code> because it can execute all valid Python code, not just expressions. The principle is similar, though.</em></p><p>What happens:</p><ol><li>Parse the whole source code</li><li>To evaluate <code>exec(&quot;def hello(): print(&#39;Hello eval!&#39;)&quot;)</code>: 2.1. Parse <code>def hello(): print(&#39;Hello eval!&#39;)</code> 2.2 Evaluate <code>def hello(): print(&#39;Hello eval!&#39;)</code></li><li>Evaluate <code>hello()</code></li></ol><p>Note, that until step 2.2, the interpreter has no idea a function <code>hello</code> exists! This makes static analysis of dynamic languages challenging. In the example, the existence of <code>hello</code> function cannot be checked just by parsing (compiling) the source code. You actually need to go and evaluate (run) the code to find out. While in a compiled language, missing function is a guaranteed compile error, in a dynamic interpreted language, it is a runtime error (which can slip unnoticed if the line calling <code>hello()</code> is, for example, behind an <code>if</code> condition and does not get executed).</p><p>In Nushell, there are <strong>exactly two steps</strong>:</p><ol><li>Parse the whole source code</li><li>Evaluate the whole source code</li></ol><p>This is the complete parse-eval sequence.</p><p>Not having <code>eval</code>-like functionality prevents <code>eval</code>-related bugs from happening. Calling a non-existent function is 100% guaranteed parse-time error in Nushell. Furthermore, after the parse step, we have a deep insight into the program and we&#39;re 100% sure it is not going to change during evaluation. This trivially allows for powerful and reliable static analysis and IDE integration which is challenging to achieve with more dynamic languages. In general, you have more peace of mind when scaling Nushell programs to bigger applications.</p>`,11),$=t("code",null,"eval",-1),B={href:"https://doc.rust-lang.org/stable/book/ch04-00-understanding-ownership.html",target:"_blank",rel:"noopener noreferrer"},F=n(`<h2 id="common-mistakes" tabindex="-1"><a class="header-anchor" href="#common-mistakes" aria-hidden="true">#</a> Common Mistakes</h2><p>By insisting on strict parse-evaluation separation, we lose much of a flexibility users expect from dynamic interpreted languages, especially other shells, such as bash, fish, zsh and others. This leads to the examples at the beginning of this page not working. Let&#39;s break them down one by one</p><p><em>Note: The following examples use <code>source</code>, but similar conclusions apply to other commands that parse Nushell source code, such as <code>use</code>, <code>overlay use</code>, <code>hide</code>, <code>register</code> or <code>source-env</code>.</em></p><h3 id="_1-sourcing-a-dynamic-path" tabindex="-1"><a class="header-anchor" href="#_1-sourcing-a-dynamic-path" aria-hidden="true">#</a> 1. Sourcing a dynamic path</h3><div class="language-text" data-ext="text"><pre class="language-text"><code>source $&quot;($my_path)/common.nu&quot;
</code></pre></div><p>Let&#39;s break down what would need to happen for this to work (assuming <code>$my_path</code> is set somewhere):</p><ol><li>Parse <code>source $&quot;($my_path)/common.nu&quot;</code></li><li>To evaluate <code>source $&quot;($my_path)/common.nu&quot;</code>: 2.1. Parse <code>$&quot;($my_path)/common.nu&quot;</code> 2.2. Evaluate <code>$&quot;($my_path)/common.nu&quot;</code> to get the file name 2.3. Parse the contents of the file 2.4. Evaluate the contents of the file</li></ol><p>You can see the process is similar to the <code>eval</code> functionality we talked about earlier. Nesting parse-evaluation cycles into the evaluation is not allowed in Nushell.</p><p>To give another perspective, here is why it is helpful to <em>think of Nushell as a compiled language</em>. Instead of</p><div class="language-text" data-ext="text"><pre class="language-text"><code>let my_path = &#39;foo&#39;
source $&quot;($my_path)/common.nu&quot;
</code></pre></div><p>imagine it being written in some typical compiled language, such as C++</p><div class="language-cpp" data-ext="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">my_path</span><span class="token punctuation">(</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;my_path + &quot;/common.h&quot;&gt;</span></span>
</code></pre></div><p>or Rust</p><div class="language-rust!" data-ext="rust!"><pre class="language-rust!"><code>let my_path = &quot;foo&quot;;
use format!(&quot;{}::common&quot;, my_path);
</code></pre></div><p>If you&#39;ve ever written a simple program in any of these languages, you can see these examples do not make a whole lot of sense. You need to have all the source code files ready and available to the compiler beforehand.</p><h3 id="_2-write-to-a-file-and-source-it-in-a-single-script" tabindex="-1"><a class="header-anchor" href="#_2-write-to-a-file-and-source-it-in-a-single-script" aria-hidden="true">#</a> 2. Write to a file and source it in a single script</h3><div class="language-text" data-ext="text"><pre class="language-text"><code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu
source &quot;output.nu&quot;
</code></pre></div><p>Here, the sourced path is static (= known at parse-time) so everything should be fine, right? Well... no. Let&#39;s break down the sequence again:</p><ol><li>Parse the whole source code 1.1. Parse <code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu</code> 1.2. Parse <code>source &quot;output.nu&quot;</code> - 1.2.1. Open <code>output.nu</code> and parse its contents</li><li>Evaluate the whole source code 2.1. Evaluate <code>&quot;def abc [] { 1 + 2 }&quot; | save output.nu</code> to generate <code>output.nu</code> 2.2. ...wait what???</li></ol><p>We&#39;re asking Nushell to read <code>output.nu</code> before it even exists. All the source code needs to be available to Nushell at parse-time, but <code>output.nu</code> is only generated during evaluation. Again, it helps here to <em>think of Nushell as a compiled language</em>.</p><h3 id="_3-change-a-directory-and-source-a-path-within" tabindex="-1"><a class="header-anchor" href="#_3-change-a-directory-and-source-a-path-within" aria-hidden="true">#</a> 3. Change a directory and source a path within</h3><p>(We assume the <code>spam/foo.nu</code> file exists.)</p><div class="language-text" data-ext="text"><pre class="language-text"><code>if (&#39;spam/foo.nu&#39; | path exists) {
    cd spam
    source-env foo.nu
}
</code></pre></div><p>This one is similar to the previous example. <code>cd spam</code> changes the directory <em>during evaluation</em> but <code>source-env</code> attempts to open and read <code>foo.nu</code> during parsing.</p><h2 id="repl" tabindex="-1"><a class="header-anchor" href="#repl" aria-hidden="true">#</a> REPL</h2>`,25),Y={href:"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop",target:"_blank",rel:"noopener noreferrer"},M=t("code",null,"nu",-1),A=n(`<div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; some code...
</code></pre></div><p>we denote a REPL entry followed by pressing Enter. For example</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; print &quot;Hello world!&quot;
Hello world!

&gt; ls
# prints files and directories...
</code></pre></div><p>means the following:</p><ol><li>Launch <code>nu</code></li><li>Type <code>print &quot;Hello world!&quot;</code>, press Enter</li><li>Type <code>ls</code>, press Enter</li></ol><p>Hopefully, that&#39;s clear. Now, when you press Enter, these things happen:</p><ol><li>Parse the line input</li><li>Evaluate the line input</li><li>Merge the environment (such as the current working directory) to the internal Nushell state</li><li>Wait for another input</li></ol><p>In other words, each REPL invocation is its own separate parse-evaluation sequence. By merging the environment back to the Nushell&#39;s state, we maintain continuity between the REPL invocations.</p><p>To give an example, we showed that</p><div class="language-text" data-ext="text"><pre class="language-text"><code>cd spam
source-env foo.nu
</code></pre></div><p>does not work because the directory will be changed <em>after</em> <code>source-env</code> attempts to read the file. Running these commands as separate REPL entries, however, works:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; cd spam

&gt; source-env foo.nu
# yay, works!
</code></pre></div><p>To see why, let&#39;s break down what happens in the example:</p><ol><li>Launch <code>nu</code></li><li>Parse <code>cd spam</code></li><li>Evaluate <code>cd spam</code></li><li><strong>Merge environment (including the current directory) into the Nushell state</strong></li><li>Parse <code>source-env foo.nu</code></li><li>Evaluate <code>source-env foo.nu</code></li><li>Merge environment (including the current directory) into the Nushell state</li></ol><p>When <code>source-env</code> tries to open <code>foo.nu</code> during the parsing in step 5., it can do so because the directory change from step 3. was merged into the Nushell state in step 4. and therefore is visible in the following parse-evaluation cycles.</p><h3 id="parse-time-evaluation" tabindex="-1"><a class="header-anchor" href="#parse-time-evaluation" aria-hidden="true">#</a> Parse-time Evaluation</h3>`,16),O=t("em",null,"a little bit",-1),j={href:"https://github.com/nushell/nushell/pull/7436",target:"_blank",rel:"noopener noreferrer"},z=n(`<p>One pattern that this unlocks is being able to <code>source</code>/<code>use</code>/etc. a path from a &quot;variable&quot;. We&#39;ve seen that</p><div class="language-text" data-ext="text"><pre class="language-text"><code>let some_path = &#39;foo/common.nu&#39;
source $some_path
</code></pre></div><p>does not work, but we can do the following:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>const some_path = &#39;foo/common.nu&#39;
source $some_path
</code></pre></div><p>We can break down what is happening again:</p><ol><li>Parse the whole source code 1.1. Parse <code>const some_path = &#39;foo/common.nu&#39;</code> - 1.1.1. Evaluate* <code>&#39;foo/common.nu&#39;</code> and store it as a <code>some_path</code> constant 1.2. Parse <code>source $some_path</code> - 1.2.1. Evaluate* <code>$some_path</code>, see that it is a constant, fetch it - 1.2.2. Parse the <code>foo/common.nu</code> file</li><li>Evaluate the whole source code 2.1. Evaluate <code>const some_path = &#39;foo/common.nu&#39;</code> (i.e., add the <code>foo/common.nu</code> string to the runtime stack as <code>some_path</code> variable) 2.2. Evaluate <code>source $some_path</code> (i.e., evaluate the contents of <code>foo/common.nu</code>)</li></ol><p>This still does not violate our rule of not having an eval function, because an eval function adds additional parsing to the evaluation step. With parse-time evaluation we&#39;re doing the opposite.</p><p>Also, note the * in steps 1.1.1. and 1.2.1. The evaluation happening during parsing is very restricted and limited to only a small subset of what is normally allowed during a regular evaluation. For example, the following is not allowed:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>const foo_contents = (open foo.nu)
</code></pre></div><p>By allowing <em>everything</em> during parse-time evaluation, we could set ourselves up to a lot of trouble (think of generating an infinite stream in a subexpression...). Generally, only a simple expressions <em>without side effects</em> are allowed, such as string literals or integers, or composite types of these literals (records, lists, tables).</p>`,10),S={href:"https://kristoff.it/blog/what-is-zig-comptime",target:"_blank",rel:"noopener noreferrer"},U=t("h2",{id:"conclusion",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#conclusion","aria-hidden":"true"},"#"),e(" Conclusion")],-1),V=t("p",null,[e('Nushell operates in a scripting language space typically dominated by "dynamic" "interpreted" languages, such as Python, bash, zsh, fish, etc. While Nushell is also "interpreted" in a sense that it runs the code immediately, instead of storing the intermediate representation (IR) to a disk, one feature sets it apart from the pack: It does not have an '),t("strong",null,"eval function"),e('. In other words, Nushell cannot parse code and manipulate its IR during evaluation. This gives Nushell one characteristic typical for "static" "compiled" languages, such as C or Rust: All the source code must be visible to the parser beforehand, just like all the source code must be available to a C or Rust compiler. For example, you cannot '),t("code",null,"source"),e(" or "),t("code",null,"use"),e(' a path computed "dynamically" (during evaluation). This is surprising for users of more traditional scripting languages, but it helps to '),t("em",null,"think of Nushell as a compiled language"),e(".")],-1);function D(G,Q){const i=s("RouterLink"),o=s("ExternalLinkIcon");return r(),c("div",null,[h,t("p",null,[e("As you probably noticed, Nushell behaves quite differently from other shells and dynamic languages. In "),a(i,{to:"/book/thinking_in_nu.html#think-of-nushell-as-a-compiled-language"},{default:d(()=>[e("Thinking in Nu")]),_:1}),e(", we advise you to "),p,e(" but we do not give much insight into why. This section hopefully fills the gap.")]),g,t("p",null,[e("First, the source code is analyzed by the parser and converted into an intermediate representation (IR), which in Nushell's case are just some data structures. Then, these data structures are passed to the engine which evaluates them and produces the result. This is nothing unusual. For example, Python's source code is typically converted into "),t("a",m,[e("bytecode"),a(o)]),e(" before evaluation.")]),f,t("p",null,[e('On the other side are languages that are typically "compiled", such as C, C++, or Rust. Assuming a simple '),t("a",v,[e('"hello world"'),a(o)]),e(" in Rust")]),y,t("p",null,[e("you first need to "),w,e(" the program into "),t("a",x,[e("machine code instructions"),a(o)]),e(" and store the binary file to a disk ("),_,e("). Then, to produce a result, you need to run the binary ("),b,e("), which passes the instructions to the CPU:")]),k,q,N,E,t("p",null,[e('Most languages considered as "dynamic" or "interpreted" have an eval function, for example Python (it has two, '),t("a",P,[e("eval"),a(o)]),e(" and "),t("a",T,[e("exec"),a(o)]),e(") or "),t("a",I,[e("Bash"),a(o)]),e(". It is used to take source code and interpret it within a running interpreter. This can get a bit confusing, so let's give a Python example:")]),R,t("p",null,[e("We've seen that without "),H,e(", the difference between compiled and interpreted languages is actually not that big. This is exactly what we mean by "),t("a",C,[e("thinking of Nushell as a compiled language"),a(o)]),e(": Despite Nushell being an interpreted language, its lack of "),W,e(" gives it characteristics and limitations typical for traditional compiled languages like C or Rust. We'll dig deeper into what it means in the next section.")]),L,t("p",null,[t("em",null,[e('Before going into examples, one note about the "dynamic" and "static" terminology. Stuff that happens at runtime (during evaluation, after parsing) is considered "dynamic". Stuff that happens before running (during parsing / compilation) is called "static". Languages that have more stuff (such as '),$,e(', type checking, etc.) happening at runtime are sometimes called "dynamic". Languages that analyze most of the information (type checking, '),t("a",B,[e("data ownership"),a(o)]),e(', etc.) before evaluating the program are sometimes called "static". The whole debate can get quite confusing, but for the purpose of this text, the main difference between a "static" and "dynamic" language is whether it has or has not the eval function.')])]),F,t("p",null,[t("a",Y,[e("REPL"),a(o)]),e(" is what happens when you run "),M,e(" without any file. You launch an interactive prompt. By")]),A,t("p",null,[e("While it is impossible to add parsing into the evaluation, we can add "),O,e(" of evaluation into parsing. This feature has been added "),t("a",j,[e("only recently"),a(o)]),e(" and we're going to expand it as needed.")]),z,t("p",null,[e(`Compiled ("static") languages also tend to have a way to convey some logic at compile time, be it C's preprocessor, Rust's macros, or `),t("a",S,[e("Zig's comptime"),a(o)]),e(". One reason is performance (if you can do it during compilation, you save the time during runtime) which is not as important for Nushell because we always do both parsing and evaluation, we do not store the parsed result anywhere (yet?). The second reason is similar to Nushell's: Dealing with limitations caused by the absence of the eval function.")]),U,V])}const J=l(u,[["render",D],["__file","how_nushell_code_gets_run.html.vue"]]);export{J as default};
