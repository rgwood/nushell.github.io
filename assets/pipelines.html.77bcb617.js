import{_ as d,z as c,A as h,X as e,C as t,T as a,$ as n,a6 as s,Q as l}from"./framework.3d018c9f.js";const r={},u=s(`<h1 id="pipelines" tabindex="-1"><a class="header-anchor" href="#pipelines" aria-hidden="true">#</a> Pipelines</h1><p>One of the core designs of Nu is the pipeline, a design idea that traces its roots back decades to some of the original philosophy behind Unix. Just as Nu extends from the single string data type of Unix, Nu also extends the idea of the pipeline to include more than just text.</p><h2 id="basics" tabindex="-1"><a class="header-anchor" href="#basics" aria-hidden="true">#</a> Basics</h2><p>A pipeline is composed of three parts: the input, the filter, and the output.</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; open &quot;Cargo.toml&quot; | inc package.version --minor | save &quot;Cargo_new.toml&quot;
</code></pre></div>`,5),m=e("code",null,'open "Cargo.toml"',-1),p=e("code",null,"ls",-1),_=e("code",null,"inc package.version --minor",-1),f=e("code",null,"inc",-1),g=s(`<p>The last command, <code>save &quot;Cargo_new.toml&quot;</code>, is an output (sometimes called a &quot;sink&quot;). An output takes input from the pipeline and does some final operation on it. In our example, we save what comes through the pipeline to a file as the final step. Other types of output commands may take the values and view them for the user.</p><p>The <code>$in</code> variable will collect the pipeline into a value for you, allowing you to access the whole stream as a parameter:</p><div class="language-nushell" data-ext="nushell"><pre class="language-nushell"><code>&gt; [1 2 3] | $in.1 * $in.2
6
</code></pre></div><h2 id="multi-line-pipelines" tabindex="-1"><a class="header-anchor" href="#multi-line-pipelines" aria-hidden="true">#</a> Multi-line pipelines</h2><p>If a pipeline is getting a bit long for one line, you can enclose it within <code>(</code> and <code>)</code> to create a subexpression:</p><div class="language-nushell" data-ext="nushell"><pre class="language-nushell"><code>(
    &quot;01/22/2021&quot; |
    parse &quot;{month}/{day}/{year}&quot; |
    get year
)
</code></pre></div>`,6),x={href:"https://www.nushell.sh/book/variables_and_subexpressions.html#subexpressions",target:"_blank",rel:"noopener noreferrer"},w=s(`<h2 id="semicolons" tabindex="-1"><a class="header-anchor" href="#semicolons" aria-hidden="true">#</a> Semicolons</h2><p>Take this example:</p><div class="language-text" data-ext="text"><pre class="language-text"><code>&gt; line1; line2 | line3
</code></pre></div><p>Here, semicolons are used in conjunction with pipelines. When a semicolon is used, no output data is produced to be piped. As such, the <code>$in</code> variable will not work when used immediately after the semicolon.</p><ul><li>As there is a semicolon after <code>line1</code>, the command will run to completion and get displayed on the screen.</li><li><code>line2</code> | <code>line3</code> is a normal pipeline. It runs, and its contents are displayed after <code>line1</code>&#39;s contents.</li></ul><h2 id="working-with-external-commands" tabindex="-1"><a class="header-anchor" href="#working-with-external-commands" aria-hidden="true">#</a> Working with external commands</h2>`,6),b=e("p",null,[e("code",null,"internal_command | external_command")],-1),k=e("p",null,[t("Data will flow from the internal_command to the external_command. This data will get converted to a string, so that they can be sent to the "),e("code",null,"stdin"),t(" of the external_command.")],-1),v=e("p",null,[e("code",null,"external_command | internal_command")],-1),y=e("code",null,"lines",-1),T=e("p",null,[e("code",null,"external_command_1 | external_command_2")],-1),N=e("p",null,[t("Nu works with data piped between two external commands in the same way as other shells, like Bash would. The "),e("code",null,"stdout"),t(" of external_command_1 is connected to the "),e("code",null,"stdin"),t(" of external_command_2. This lets data flow naturally between the two commands.")],-1),q=e("h2",{id:"behind-the-scenes",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#behind-the-scenes","aria-hidden":"true"},"#"),t(" Behind the scenes")],-1),C=e("code",null,"ls",-1),I=e("code",null,"table",-1),A=e("code",null,"table",-1),B=e("p",null,"In effect, the command:",-1),L=e("div",{class:"language-text","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`> ls
`)])],-1),$=e("p",null,"And the pipeline:",-1),V=e("div",{class:"language-text","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`> ls | table
`)])],-1),E=e("p",null,"Are one and the same.",-1);function S(U,j){const o=l("RouterLink"),i=l("ExternalLinkIcon");return c(),h("div",null,[u,e("p",null,[t("The first command, "),m,t(`, is an input (sometimes also called a "source" or "producer"). This creates or loads data and feeds it into a pipeline. It's from input that pipelines have values to work with. Commands like `),a(o,{to:"/book/commands/ls.html"},{default:n(()=>[p]),_:1}),t(" are also inputs, as they take data from the filesystem and send it through the pipelines so that it can be used.")]),e("p",null,[t("The second command, "),_,t(", is a filter. Filters take the data they are given and often do something with it. They may change it (as with the "),a(o,{to:"/book/commands/inc.html"},{default:n(()=>[f]),_:1}),t(" command in our example), or they may do another operation, like logging, as the values pass through.")]),g,e("p",null,[t("Also see "),e("a",x,[t("Subexpressions"),a(i)])]),w,e("p",null,[t("Nu commands communicate with each other using the Nu data types (see "),a(o,{to:"/book/types_of_data.html"},{default:n(()=>[t("types of data")]),_:1}),t("), but what about commands outside of Nu? Let's look at some examples of working with external commands:")]),b,k,v,e("p",null,[t("Data coming from an external command into Nu will come in as bytes that Nushell will try to automatically convert to UTF-8 text. If successful, a stream of text data will be sent to internal_command. If unsuccessful, a stream of binary data will be sent to internal command. Commands like "),a(o,{to:"/book/commands/lines.html"},{default:n(()=>[y]),_:1}),t(" help make it easier to bring in data from external commands, as it gives discrete lines of data to work with.")]),T,N,q,e("p",null,[t("You may have wondered how we see a table if "),a(o,{to:"/book/commands/ls.html"},{default:n(()=>[C]),_:1}),t(" is an input and not an output. Nu adds this output for us automatically using another command called "),a(o,{to:"/book/commands/table.html"},{default:n(()=>[I]),_:1}),t(". The "),a(o,{to:"/book/commands/table.html"},{default:n(()=>[A]),_:1}),t(" command is appended to any pipeline that doesn't have an output. This allows us to see the result.")]),B,L,$,V,E])}const F=d(r,[["render",S],["__file","pipelines.html.vue"]]);export{F as default};
